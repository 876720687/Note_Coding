"""
请参阅文档中的两个作业要求和下面所有
显示to do的部分。
"""

from typing import List
import numpy as np
from scipy.ndimage import center_of_mass
'''
scipy.ndimage.center_of_mass(input, labels=None, index=None)[source]

Calculate the center of mass of the values of an array at labels.
计算质心的位置

Parameters
inputndarray
Data from which to calculate center-of-mass. The masses can either be positive or negative.

labelsndarray, optional
Labels for objects in input, as generated by ndimage.label. Only used with index. Dimensions must be the same as input.

indexint or sequence of ints, optional
Labels for which to calculate centers-of-mass. If not specified, all labels greater than zero are used. Only used with labels.

Returns
center_of_masstuple, or list of tuples
Coordinates of centers-of-mass.
'''


def get_orientations_possible(block: np.ndarray) -> List[List[dict]]:
    """给定一个 3D numpy 数组，查看它的形状以确定它有多少种方式
     可以在每个轴上旋转以得到（理论上）不同的阵列
     仍然具有相同的形状.

    if all three dimensions are different sizes, then we have 3 more
    orientations, excluding the original, which are all 180-degree rotations.

    if just two dimensions match size, we have 7 plus original. 90-degree
    rotations are around the unique-length axis.

    if all three dimensions match (a cube), then we have 23 plus original.

    :param block: a numpy array of 3 dimensions.
    :return: a list of the ways we can rotate the block. Each is a list of dicts containing parameters for np.rot90()

    >>> a = np.arange(64, dtype=int).reshape(4, 4, 4)  # a cube
    >>> rotations = get_orientations_possible(a)
    >>> len(rotations)
    23
    >>> rotations  # doctest: +ELLIPSIS
    [[{'k': 1, 'axes': (0, 1)}], [{'k': 2, 'axes': (0, 1)}], ... [{'k': 3, 'axes': (1, 2)}, {'k': 3, 'axes': (0, 2)}]]
    >>> a = a.reshape(2, 4, 8)
    >>> len(get_orientations_possible(a))
    3
    >>> a = a.reshape(16, 2, 2)
    >>> len(get_orientations_possible(a))
    7
    >>> get_orientations_possible(np.array([[1, 2], [3, 4]]))
    Traceback (most recent call last):
    ValueError: array parameter block must have exactly 3 dimensions.
    >>> block_1 = np.load(file='data/marble_block_1.npy')
    >>> len(get_orientations_possible(block_1))
    7
    """

    if len(block.shape) != 3:
        raise ValueError('array parameter block must have exactly 3 dimensions.')

    # Create list of the 23 possible 90-degree rotation combinations -- params to call rot90():
    poss = [
        [{'k': 1, 'axes': (0, 1)}],  # 1-axis rotations:
        [{'k': 2, 'axes': (0, 1)}],
        [{'k': 3, 'axes': (0, 1)}],
        [{'k': 1, 'axes': (0, 2)}],
        [{'k': 2, 'axes': (0, 2)}],
        [{'k': 3, 'axes': (0, 2)}],
        [{'k': 1, 'axes': (1, 2)}],
        [{'k': 2, 'axes': (1, 2)}],
        [{'k': 3, 'axes': (1, 2)}],
        [{'k': 1, 'axes': (0, 1)}, {'k': 1, 'axes': (0, 2)}],  # 2-axis rotations:
        [{'k': 1, 'axes': (0, 1)}, {'k': 2, 'axes': (0, 2)}],
        [{'k': 1, 'axes': (0, 1)}, {'k': 3, 'axes': (0, 2)}],
        [{'k': 2, 'axes': (0, 1)}, {'k': 1, 'axes': (0, 2)}],
        [{'k': 2, 'axes': (0, 1)}, {'k': 3, 'axes': (0, 2)}],
        [{'k': 3, 'axes': (0, 1)}, {'k': 1, 'axes': (0, 2)}],
        [{'k': 3, 'axes': (0, 1)}, {'k': 2, 'axes': (0, 2)}],
        [{'k': 3, 'axes': (0, 1)}, {'k': 3, 'axes': (0, 2)}],
        [{'k': 1, 'axes': (1, 2)}, {'k': 1, 'axes': (0, 2)}],
        [{'k': 1, 'axes': (1, 2)}, {'k': 2, 'axes': (0, 2)}],
        [{'k': 1, 'axes': (1, 2)}, {'k': 3, 'axes': (0, 2)}],
        [{'k': 3, 'axes': (1, 2)}, {'k': 1, 'axes': (0, 2)}],
        [{'k': 3, 'axes': (1, 2)}, {'k': 2, 'axes': (0, 2)}],
        [{'k': 3, 'axes': (1, 2)}, {'k': 3, 'axes': (0, 2)}],
        ]

    # consider the 3-tuple shape of axes numbered 0, 1, 2 to represent (height, depth, width)
    (height, depth, width) = block.shape

    if height == depth == width:
        return poss  # return all possibilities, it's a cube

    # TODO: 完成其他情况下的此函数...
    # Hint, the results will be parts of the 23-item list above, read the Docstring!

    changed_blocks=[]
    for i in poss[:9]:
        for j in i:
            changed_blocks.append(np.rot90(block, k=j['k'], axes=j['axes']))
    temp=[]
    for i in poss[9:]:
        #print(i[0],i[1])
        temp=np.rot90(block,k=i[0]['k'],axes=i[0]['axes'])
        changed_blocks.append(np.rot90(temp, k=j['k'], axes=j['axes']))

    ans = 0
    for i in range(len(changed_blocks)):
        for j in range(i+1):
            if( (changed_blocks[i] == changed_blocks[j]).all()):
                ans+=1




def carve_sculpture_from_density_block(shape: np.ndarray, block: np.ndarray) -> np.ndarray:
    """
    将marble_block_1切割成shape_1方式是通过找质心？

    The shape array guides our carving. It indicates which parts of the
    material block to keep (the 1 values) and which to carve away (the 0 values),
    producing a new array that defines a sculpture and its varying densities.
    It must have NaN values everywhere that was 'carved' away.

    :param shape: array to guide carving into some 3D shape
    :param block: array describing densities throughout the raw material block
    :return: array of densities in the resulting sculpture, in same orientation.
    :raises: ValueError if the input arrays don't match in size and shape.
    """
    # TODO: write the code for this function, which could be as short as around 4 lines of code!
    # TODO: Add a few good, working Doctests


def is_stable(sculpture: np.ndarray) -> bool:
    """
    判断切割前后是否仍然稳定

    Given a 'sculpted' 3D numpy array, where number values represent densities and
    NaN values represent the areas carved away, determine if it will sit stably
    upon its base or not.

    :param sculpture: array representing a sculpture of variable density material.
    """
    # TODO: Complete this function.
    # TODO: Add a few good, working Doctests


def analyze_sculptures(block_filenames: list, shape_filenames: list):
    """
    Given all the filenames of blocks and sculpture shapes to carve,
    analyze them in all compatible block rotations to show their resulting
    densities and stabilities.  See the 题目要求文件 for an example
    output format.

    :param block_filenames:
    :param shape_filenames:
    :return:
    """
    # TODO: Complete this function.
    # TODO: Add a few good, working Doctests


def are_rotations_distinct(list_of_rotations: List[List[dict]], verbose=False) -> bool:
    """Given a list of list of 3D rotation combinations suitable for using with np.rot90()
    and like returned from the get_orientations_possible() function, determine whether any
    of the rotations are equivalent, and discard the duplicates.

    The purpose is to detect situations where a combination of rotations would produce either
    the original unmodified array or the same orientation as any previous one in the list.

    NOTE: This function is already complete! It is provided as an example of rotation
    calcul                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ations, good Doctests, and it could be useful to you as part of your solution.

    :param list_of_rotations: a list, such as returned by get_orientations_possible()
    :param verbose: if True, will print details to console, otherwise silent.
    :return: True, if all listed rotation combinations produce distinct orientations.

    >>> x = [[{'k': 4, 'axes': (0, 1)}]]  # 4x90 degrees is a full rotation
    >>> are_rotations_distinct(x)
    False
    >>> y1 = [[{'k': 3, 'axes': (1, 2)}], [{'k': 1, 'axes': (0, 1)}, {'k': 1, 'axes': (2, 0)}]]
    >>> are_rotations_distinct(y1)
    True
    >>> x = [[{'k': 2, 'axes': (0, 1)}, {'k': 2, 'axes': (0, 1)}]]  # also a full rotation
    >>> are_rotations_distinct(x)
    False
    >>> y2 = y1 + [[{'k': 1, 'axes': (1, 2)}, {'k': 3, 'axes': (1, 0)}]]  # equiv. to earlier
    >>> are_rotations_distinct(y2, verbose=True)
    combination #1: [{'k': 3, 'axes': (1, 2)}] ok.
    combination #2: [{'k': 1, 'axes': (0, 1)}, {'k': 1, 'axes': (2, 0)}] ok.
    combination #3: [{'k': 1, 'axes': (1, 2)}, {'k': 3, 'axes': (1, 0)}] not unique.
    it results in the same array as combination 2
    False
    """
    # 创建一个小立方体来尝试所有的输入旋转。 它具有独特的价值
    #  因此没有不同的旋转会意外地创建一个等效的数组。
    cube = np.arange(0, 27).reshape((3, 3, 3))

    # Note: 在下面的代码中，数组必须以字符串形式附加到orientations_seen 列表中，
    #  否则Numpy 会误解if ... in orientations_seen 表达式的意图。


    orientations_seen = [cube.tostring()]  # 记录初始化

    count = 0
    for combo in list_of_rotations:
        count += 1
        if verbose:
            print('combination #{}: {}'.format(count, combo), end='')

        r = cube  # 从未修改的立方体视图开始进行比较
        for r90 in combo:  # 应用此组合中给出的所有roatataion
            r = np.rot90(r, k=r90['k'], axes=r90['axes'])
        if r.tostring() in orientations_seen:
            if verbose:
                print(' not unique.')
                if r.tostring() == cube.tostring():
                    print('it results in the original 3d array.')
                else:
                    print('it results in the same array as combination',
                          orientations_seen.index(r.tostring()))
            return False
        else:
            if verbose:
                print(' ok.')
        orientations_seen.append(r.tostring())
    return True


if __name__ == '__main__':

    # 这整个部分将需要进行重大更改。 这里只是一些加载和操作数组的例子。

    # 加载一个“block”的可变密度大理石:
    marble_block_1 = np.load(file='/接单/Structure/marble_block_1.npy')

    # 加载一个数组来描述我们想要用大理石雕刻的雕塑的 3D 形状:
    shape_1 = np.load(file='/接单/Structure/shape_1.npy')

    print(marble_block_1.shape)
    print(shape_1.shape)

    print('mean density of unmodified block: {:.2f}'.format(np.nanmean(marble_block_1.astype('float32'))))